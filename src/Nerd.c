#define F_CPU                16'000'000
#define PROGRAM_NERD         true
#define BOARD_MEGA_2560_REV3 true
#define PIN_MATRIX_SS        2
#define PIN_SD_SS            3
#define SPI_PRESCALER        SPIPrescaler_2
#define USART_N              3
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <stdint.h>
#include <string.h>
#include "defs.h"
#include "W:/data/words_table_of_contents.h" // Generated by Microservices.c.
#include "pin.c"
#include "misc.c"
#include "usart.c"
#include "spi.c"
#include "sd.c"
#if DEBUG
	#include "matrix.c"
#endif

#if DEBUG
	static void
	debug_chars(char* data, u16 length)
	{
		for (u16 i = 0; i < length; i += 1)
		{
			while (!(UCSR0A & (1 << UDRE0))); // Wait for USART transmission buffer to free up.
			UDR0 = data[i];
		}
	}

	static void
	debug_dump(char* file_path, u16 line_number)
	{
		u64 bits            = ((u64) line_number) << 48;
		u8  file_name_index = 0;
		for (u8 i = 0; file_path[i]; i += 1)
		{
			if (file_path[i] == '/' || file_path[i] == '\\')
			{
				file_name_index = i + 1;
			}
		}
		for
		(
			u8 i = 0;
			i < 6 && file_path[file_name_index + i];
			i += 1
		)
		{
			bits |= ((u64) file_path[file_name_index + i]) << (i * 8);
		}
		matrix_init(); // Reinitialize matrix in case the dump occurred mid communication or we haven't had it initialized yet.
		matrix_set(bits);
		debug_cstr("\nDUMPED @ File(");
		debug_cstr(file_path);
		debug_cstr(") @ Line(");
		debug_u64(line_number);
		debug_cstr(").\n");
	}
#endif

int
main(void)
{
	#if DEBUG // Configure USART0 to have 250Kbps. See: Source(27) @ Table(22-12) @ Page(226).
		UCSR0A = 1 << U2X0;
		UBRR0  = 7;
		UCSR0B = 1 << TXEN0;
		debug_cstr("\n\n--------------------------------\n\n"); // If terminal is opened early, lots of junk could appear due to noise; this helps separate.
	#endif

	usart_init();
	spi_init();

	#if DEBUG // 8x8 LED dot matrix to have visual debug info. Must be initialized first before SD or else it messes with SPI communications...
		matrix_init();
	#endif

	sd_init();

	//
	// Find sectors of the word stream.
	//

	u32 word_stream_cluster_addresses[32] = {0}; // Zero is never a valid cluster address.
	u8  sectors_per_cluster_exp           = 0;   // Max value is 7.

	{
		//
		// Read master boot record.
		//

		sd_read(0);
		struct MasterBootRecord* mbr = (struct MasterBootRecord*) &sd_sector;
		static_assert(sizeof(*mbr) == sizeof(sd_sector));

		if (mbr->partitions[0].partition_type != MASTER_BOOT_RECORD_PARTITION_TYPE_FAT32_LBA)
		{
			error(); // Unknown partition type..!
		}

		u32 boot_sector_address = mbr->partitions[0].fst_sector_address;

		//
		// Read FAT32 boot sector.
		//

		sd_read(boot_sector_address);
		struct FAT32BootSector* boot_sector = (struct FAT32BootSector*) &sd_sector;
		static_assert(sizeof(*boot_sector) == sizeof(sd_sector));

		if
		(
			!(
				boot_sector->BPB_BytsPerSec == FAT32_SECTOR_SIZE
				&& (boot_sector->BPB_SecPerClus & (boot_sector->BPB_SecPerClus - 1)) == 0
				&& boot_sector->BPB_RootEntCnt == 0
				&& boot_sector->BPB_TotSec16 == 0
				&& boot_sector->BPB_FATSz16 == 0
				&& boot_sector->BPB_FSVer == 0
				&& boot_sector->BS_Reserved == 0
				&& boot_sector->BS_BootSig == 0x29
				&& memeq("FAT32   ", boot_sector->BS_FilSysType, sizeof(boot_sector->BS_FilSysType))
				&& boot_sector->BS_BootSign == 0xAA55
			)
		)
		{
			error(); // Not the boot sector we're expecting...
		}

		for (u8 i = 0; i < 8; i += 1) // Get exponent of sectors per cluster.
		{
			if (boot_sector->BPB_SecPerClus & (1 << i))
			{
				sectors_per_cluster_exp = i;
				break;
			}
		}

		u32 root_cluster        = boot_sector->BPB_RootClus;
		u32 fat_address         = boot_sector_address + boot_sector->BPB_RsvdSecCnt;
		u32 data_region_address = fat_address + boot_sector->BPB_NumFATs * boot_sector->BPB_FATSz32;

		//
		// Search through root directory for the word stream binary file.
		//

		char word_stream_file_name[FAT32_SHORT_NAME_LENGTH + FAT32_SHORT_EXTENSION_LENGTH] = {0};
		memset(word_stream_file_name, ' ', sizeof(word_stream_file_name));

		static_assert(sizeof(WORD_STREAM_NAME) - 1 <= FAT32_SHORT_NAME_LENGTH);
		for (u8 i = 0; i < sizeof(WORD_STREAM_NAME) - 1; i += 1)
		{
			word_stream_file_name[i] = to_upper(pgm_char(PSTR(WORD_STREAM_NAME)[i]));
		}
		static_assert(sizeof(WORD_STREAM_EXTENSION) - 1 <= FAT32_SHORT_EXTENSION_LENGTH);
		for (u8 i = 0; i < sizeof(WORD_STREAM_EXTENSION) - 1; i += 1)
		{
			word_stream_file_name[FAT32_SHORT_NAME_LENGTH + i] = to_upper(pgm_char(PSTR(WORD_STREAM_EXTENSION)[i]));
		}

		for
		(
			u32 cluster = root_cluster;
			(cluster & 0x0FFF'FFFF) != 0x0FFF'FFFF;
		)
		{
			for (u8 sector_index = 0; sector_index < (1 << sectors_per_cluster_exp); sector_index += 1)
			{
				sd_read(data_region_address + ((cluster - 2) << sectors_per_cluster_exp) + sector_index);

				for (u8 entry_index = 0; entry_index < sizeof(sd_sector) / sizeof(union FAT32DirEntry); entry_index += 1)
				{
					// Short entries are only considered; long entries can be done, but that's a lot of complexity for not much.
					struct FAT32DirEntryShort* entry = &((union FAT32DirEntry*) &sd_sector)[entry_index].short_entry;
					static_assert(countof(word_stream_file_name) == countof(entry->DIR_Name));

					if (!entry->DIR_Name[0]) // Current and future entries are unallocated.
					{
						goto STOP_SEARCHING_ROOT_DIRECTORY;
					}
					else if
					(
						entry->DIR_Name[0] != 0xE5                                                                 // Entry is allocated.
						&& !(entry->DIR_Attr & ~(FAT32DirEntryAttrFlag_archive | FAT32DirEntryAttrFlag_read_only)) // Attributes indicate short entry of a file.
						&& memeq(word_stream_file_name, entry->DIR_Name, countof(entry->DIR_Name))                 // File name matches?
					)
					{
						word_stream_cluster_addresses[0] = (((u32) entry->DIR_FstClusHI) << 16) | entry->DIR_FstClusLO;
						goto STOP_SEARCHING_ROOT_DIRECTORY;
					}
				}
			}

			sd_read(fat_address + cluster / FAT32_CLUSTER_ENTRIES_PER_TABLE_SECTOR);
			cluster = ((u32*) sd_sector)[cluster % FAT32_CLUSTER_ENTRIES_PER_TABLE_SECTOR];
		}
		STOP_SEARCHING_ROOT_DIRECTORY:;

		if (!word_stream_cluster_addresses[0])
		{
			error(); // We couldn't find the word stream binary file!
		}

		//
		// Get all clusters of the file.
		//

		for
		(
			u8 cluster_index = 1;
			;
			cluster_index += 1
		)
		{
			sd_read(fat_address + word_stream_cluster_addresses[cluster_index - 1] / FAT32_CLUSTER_ENTRIES_PER_TABLE_SECTOR);
			word_stream_cluster_addresses[cluster_index] = ((u32*) sd_sector)[word_stream_cluster_addresses[cluster_index - 1] % FAT32_CLUSTER_ENTRIES_PER_TABLE_SECTOR];

			if ((word_stream_cluster_addresses[cluster_index] & 0x0FFF'FFFF) == 0x0FFF'FFFF)
			{
				word_stream_cluster_addresses[cluster_index] = 0;
				break;
			}
			else if (cluster_index == countof(word_stream_cluster_addresses) - 1)
			{
				error(); // Too many clusters!
			}
		}

		//
		// Convert the clusters into sector addresses.
		//

		for
		(
			u8 i = 0;
			i < countof(word_stream_cluster_addresses) && word_stream_cluster_addresses[i];
			i += 1
		)
		{
			word_stream_cluster_addresses[i] = data_region_address + ((word_stream_cluster_addresses[i] - 2) << sectors_per_cluster_exp);
		}
	}

//	//for (u8 i = 0; i < countof(word_stream_cluster_addresses); i += 1)
//	//{
//	//	debug_u64(word_stream_cluster_addresses[i]);
//	//	debug_char('\n');
//	//}
//
//	enum Language language                 = Language_english;
//	u8            upper_word_length        = 4;
//	u8            language_max_word_length = pgm_u8(WORDS_TABLE_OF_CONTENTS[language].max_word_length);
//	u8            language_alphabet_length = pgm_u8(LANGUAGE_INFO[language].alphabet_length);
//
//	const u16* curr_entry_count_reader =
//		&pgm_u16_ptr(WORDS_TABLE_OF_CONTENTS[language].entry_counts)
//			[(language_max_word_length - upper_word_length) * language_alphabet_length];
//
//	u32 length_offset = pgm_u32(pgm_u32_ptr(WORDS_TABLE_OF_CONTENTS[language].length_offsets)[language_max_word_length - upper_word_length]);
//	u32 cluster_index = length_offset >> (FAT32_SECTOR_SIZE_EXP + sectors_per_cluster_exp);
//	u8  sector_index  = (u8) ((length_offset >> FAT32_SECTOR_SIZE_EXP) & ((1 << sectors_per_cluster_exp) - 1));
//	u16 byte_index    =        length_offset                           & ((1 << FAT32_SECTOR_SIZE_EXP  ) - 1);
//
//	for
//	(
//		u8 word_length = upper_word_length;
//		word_length >= MIN_WORD_LENGTH;
//		word_length -= 1
//	)
//	{
//		for (u8 alphabet_index = 0; alphabet_index < language_alphabet_length; alphabet_index += 1)
//		{
//			u16 entry_count = pgm_u16(*curr_entry_count_reader);
//			curr_entry_count_reader += 1;
//
//			debug_cstr("Length ");
//			debug_u64 (word_length);
//			debug_cstr(" | Alphabet ");
//			debug_u64 (alphabet_index);
//			debug_cstr(" | ");
//			debug_u64 (entry_count);
//			debug_cstr(" entries | Cluster #");
//			debug_u64 (cluster_index);
//			debug_cstr(" | Sector #");
//			debug_u64 (sector_index);
//			debug_cstr(" | Byte #");
//			debug_u64 (byte_index);
//			debug_char('\n');
//
//
//			if (true)
//			{
//				u8  word_alphabet_indices[ABSOLUTE_MAX_WORD_LENGTH] = {0};
//				u16 entries_remaining                               = entry_count;
//
//				sd_read(word_stream_cluster_addresses[cluster_index] + sector_index);
//				while (entries_remaining)
//				{
//					u8 packed_word[PACKED_WORD_SIZE(ABSOLUTE_MAX_WORD_LENGTH)] = {0};
//					for (u8 i = 0; i < PACKED_WORD_SIZE(word_length); i += 1)
//					{
//						packed_word[i]  = sd_sector[byte_index];
//						byte_index     += 1;
//						if (byte_index >> FAT32_SECTOR_SIZE_EXP)
//						{
//							sector_index  += byte_index   >> FAT32_SECTOR_SIZE_EXP;
//							cluster_index += sector_index >> sectors_per_cluster_exp;
//							sector_index  &= ((1 << sectors_per_cluster_exp) - 1);
//							byte_index    &= ((1 << FAT32_SECTOR_SIZE_EXP  ) - 1);
//							sd_read(word_stream_cluster_addresses[cluster_index] + sector_index);
//						}
//					}
//
//					// for (u8 word_alphabet_indices_index = 0; word_alphabet_indices_index < word_length; word_alphabet_indices_index += 1)
//					// {
//					// }
//
//					entries_remaining -= 1;
//				}
//			}
//			else
//			{
//				byte_index    += entry_count * PACKED_WORD_SIZE(word_length); // This probably wouldn't overflow...
//				sector_index  += byte_index   >> FAT32_SECTOR_SIZE_EXP;
//				cluster_index += sector_index >> sectors_per_cluster_exp;
//				sector_index  &= ((1 << sectors_per_cluster_exp) - 1);
//				byte_index    &= ((1 << FAT32_SECTOR_SIZE_EXP  ) - 1);
//			}
//
//			debug_char('\n');
//		}
//	}
//
//	matrix_set
//	(
//		(((u64) 0b00001000) << (8 * 0)) |
//		(((u64) 0b00000100) << (8 * 1)) |
//		(((u64) 0b00101000) << (8 * 2)) |
//		(((u64) 0b01000000) << (8 * 3)) |
//		(((u64) 0b01000000) << (8 * 4)) |
//		(((u64) 0b00101000) << (8 * 5)) |
//		(((u64) 0b00000100) << (8 * 6)) |
//		(((u64) 0b00001000) << (8 * 7))
//	);

//	//
//	// Wait for packet from Diplomat.
//	//
//
//	matrix_set
//	(
//		(((u64) 0b00000000) << (8 * 0)) |
//		(((u64) 0b00111110) << (8 * 1)) |
//		(((u64) 0b01000000) << (8 * 2)) |
//		(((u64) 0b01111100) << (8 * 3)) |
//		(((u64) 0b01000000) << (8 * 4)) |
//		(((u64) 0b00111110) << (8 * 5)) |
//		(((u64) 0b00000000) << (8 * 6)) |
//		(((u64) 0b00000000) << (8 * 7))
//	);
//
//	struct DiplomatPacket diplomat_packet = {0};
//	for (u8 i = 0; i < sizeof(diplomat_packet); i += 1)
//	{
//		((u8*) &diplomat_packet)[i] = usart_rx();
//	}
//
//	//
//	//
//	//
//
//	matrix_set
//	(
//		(((u64) 0b00000000) << (8 * 0)) |
//		(((u64) 0b00000000) << (8 * 1)) |
//		(((u64) 0b01111110) << (8 * 2)) |
//		(((u64) 0b00010010) << (8 * 3)) |
//		(((u64) 0b00010010) << (8 * 4)) |
//		(((u64) 0b00001100) << (8 * 5)) |
//		(((u64) 0b00000000) << (8 * 6)) |
//		(((u64) 0b00000000) << (8 * 7))
//	);
//
//	debug_cstr("WordGame: ");
//	debug_u64(diplomat_packet.wordgame);
//	debug_cstr("\n");
//
//	for
//	(
//		u8 y = WORDGAME_MAX_DIM_SLOTS_Y;
//		y--;
//	)
//	{
//		for (u8 x = 0; x < WORDGAME_MAX_DIM_SLOTS_X; x += 1)
//		{
//			debug_u64 (diplomat_packet.board[y][x]);
//			debug_char(' ');
//		}
//		debug_char('\n');
//	}
//
//	u8 counter = 0;
//	while (true)
//	{
//		if (usart_rx_available()) // Diplomat signaled that it's ready for next command?
//		{
//			counter += 1;
//
//			usart_rx(); // Eat dummy signal byte.
//			usart_tx(counter);
//			matrix_set
//			(
//				(
//					(((u64) 0b00000000) << (8 * 0)) |
//					(((u64) 0b00000000) << (8 * 1)) |
//					(((u64) 0b00100100) << (8 * 2)) |
//					(((u64) 0b01001010) << (8 * 3)) |
//					(((u64) 0b01010010) << (8 * 4)) |
//					(((u64) 0b00100100) << (8 * 5)) |
//					(((u64) 0b00000000) << (8 * 6)) |
//					(((u64) 0b00000000) << (8 * 7))
//				) + counter
//			);
//		}
//	}

	for(;;);
}
