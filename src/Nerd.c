#define F_CPU             16'000'000
#define PROGRAM_NERD      true
#define SPI_PRESCALER     SPIPrescaler_2
#define USART_N           3
#define PIN_NERD_WAITING 33
#define PIN_SD_SS        49
#define PIN_ERROR        32
#define PIN_XMDT(X) /* See: Source(18). */ \
	X(0     , E, 0) X(1      , E, 1) X(2       , E, 4) X(3       , E, 5) X( 4, G, 5) X(5 , E, 3) \
	X(6     , H, 3) X(7      , H, 4) X(8       , H, 5) X(9       , H, 6) X(10, B, 4) X(11, B, 5) \
	X(12    , B, 6) X(13     , B, 7) X(14      , J, 1) X(15      , J, 0) X(16, H, 1) X(17, H, 0) \
	X(18    , D, 3) X(19     , D, 2) X(20      , D, 1) X(21      , D, 0) X(22, A, 0) X(23, A, 1) \
	X(24    , A, 2) X(25     , A, 3) X(26      , A, 4) X(27      , A, 5) X(28, A, 6) X(29, A, 7) \
	X(30    , C, 7) X(31     , C, 6) X(32      , C, 5) X(33      , C, 4) X(34, C, 3) X(35, C, 2) \
	X(36    , C, 1) X(37     , C, 0) X(38      , D, 7) X(39      , G, 2) X(40, G, 1) X(41, G, 0) \
	X(42    , L, 7) X(43     , L, 6) X(44      , L, 5) X(45      , L, 4) X(46, L, 3) X(47, L, 2) \
	X(48    , L, 1) X(49     , L, 0) X(50      , B, 3) X(51      , B, 2) X(52, B, 1) X(53, B, 0) \
	X(SPI_SS, B, 0) X(SPI_CLK, B, 1) X(SPI_MOSI, B, 2) X(SPI_MISO, B, 3)
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <util/crc16.h>
#include <stdint.h>
#include <string.h>
#include "defs.h"
#include "W:/data/words_table_of_contents.h" // Generated by Microservices.c.
#include "pin.c"
#include "misc.c"
#include "usart.c"
#include "spi.c"
#include "sd.c"
#include "timer.c"

#if DEBUG
	static void
	debug_chars(char* data, u16 length)
	{
		for (u16 i = 0; i < length; i += 1)
		{
			while (!(UCSR0A & (1 << UDRE0))); // Wait for USART transmission buffer to free up.
			UDR0 = data[i];
		}
	}

	static void
	debug_dump(char* file_path, u16 line_number)
	{
		debug_cstr("\nDUMPED @ File(");
		debug_cstr(file_path);
		debug_cstr(") @ Line(");
		debug_u64(line_number);
		debug_cstr(").\n");
	}

	static u8
	debug_rx(char* dst, u16 dst_size) // Note that PuTTY sends only '\r' (0x13) for keyboard enter.
	{
		u8 result = 0;
		while (result < dst_size && UCSR0A & (1 << RXC0))
		{
			dst[result] = UDR0;
			result += 1;
		}
		return result;
	}

	static void
	debug_wordbites_piece(struct WordBitesPiece piece)
	{
		switch (piece.orientation)
		{
			case WordBitesPieceOrientation_none: debug_char('['); break;
			case WordBitesPieceOrientation_hort: debug_char('('); break;
			case WordBitesPieceOrientation_vert: debug_char('/'); break;
		}

		debug_char('A' + piece.alphabet_indices[0]);

		if (piece.orientation == WordBitesPieceOrientation_hort)
		{
			debug_char('A' + piece.alphabet_indices[1]);
		}

		switch (piece.orientation)
		{
			case WordBitesPieceOrientation_none: debug_char(']' ); break;
			case WordBitesPieceOrientation_hort: debug_char(')' ); break;
			case WordBitesPieceOrientation_vert: debug_char('\\'); break;
		}

		debug_char(' ');
		if (piece.orientation != WordBitesPieceOrientation_hort)
		{
			debug_char(' ');
		}

		debug_char('(');
		debug_u64 (piece.position.x);
		debug_char(',');
		debug_u64 (piece.position.y);
		debug_cstr(")\n");

		if (piece.orientation == WordBitesPieceOrientation_vert)
		{
			debug_char('\\');
			debug_char('A' + piece.alphabet_indices[1]);
			debug_cstr("/\n");
		}
	}

	static void
	debug_wordbites_board(void)
	{
		char buffer[WORDGAME_MAX_DIM_SLOTS][WORDGAME_MAX_DIM_SLOTS][3] = {0};

		for (u8 y = 0; y < board_dim_slots.y; y += 1)
		{
			for (u8 x = 0; x < board_dim_slots.x; x += 1)
			{
				buffer[y][x][0] = ' ';
				buffer[y][x][1] = '*';
				buffer[y][x][2] = ' ';
			}
		}

		for (u8 i = 0; i < WORDBITES_PIECES_COUNT; i += 1)
		{
			u8_2 delta =
				{
					wordbites_pieces[i].orientation == WordBitesPieceOrientation_hort,
					wordbites_pieces[i].orientation == WordBitesPieceOrientation_vert,
				};

			if
			(
				wordbites_pieces[i].position.x + delta.x >= board_dim_slots.x &&
				wordbites_pieces[i].position.y + delta.y >= board_dim_slots.y
			)
			{
				error(); // Out of bounds piece!
			}

			if
			(
				buffer[wordbites_pieces[i].position.y          ][wordbites_pieces[i].position.x          ][1] != '*' ||
				buffer[wordbites_pieces[i].position.y + delta.y][wordbites_pieces[i].position.x + delta.x][1] != '*'
			)
			{
				error(); // Overlapping piece!
			}

			switch (wordbites_pieces[i].orientation)
			{
				case WordBitesPieceOrientation_none: buffer[wordbites_pieces[i].position.y][wordbites_pieces[i].position.x][0] = '['; break;
				case WordBitesPieceOrientation_hort: buffer[wordbites_pieces[i].position.y][wordbites_pieces[i].position.x][0] = '('; break;
				case WordBitesPieceOrientation_vert: buffer[wordbites_pieces[i].position.y][wordbites_pieces[i].position.x][0] = '/'; break;
			}

			buffer[wordbites_pieces[i].position.y][wordbites_pieces[i].position.x][1] = 'A' + wordbites_pieces[i].alphabet_indices[0];

			switch (wordbites_pieces[i].orientation)
			{
				case WordBitesPieceOrientation_none: buffer[wordbites_pieces[i].position.y][wordbites_pieces[i].position.x][2] = ']';  break;
				case WordBitesPieceOrientation_hort: buffer[wordbites_pieces[i].position.y][wordbites_pieces[i].position.x][2] = ' ';  break;
				case WordBitesPieceOrientation_vert: buffer[wordbites_pieces[i].position.y][wordbites_pieces[i].position.x][2] = '\\'; break;
			}

			switch (wordbites_pieces[i].orientation)
			{
				case WordBitesPieceOrientation_none: buffer[wordbites_pieces[i].position.y + delta.y][wordbites_pieces[i].position.x + delta.x][0] = '[';  break;
				case WordBitesPieceOrientation_hort: buffer[wordbites_pieces[i].position.y + delta.y][wordbites_pieces[i].position.x + delta.x][0] = ' ';  break;
				case WordBitesPieceOrientation_vert: buffer[wordbites_pieces[i].position.y + delta.y][wordbites_pieces[i].position.x + delta.x][0] = '\\'; break;
			}

			buffer[wordbites_pieces[i].position.y + delta.y][wordbites_pieces[i].position.x + delta.x][1] = 'A' + wordbites_pieces[i].alphabet_indices[1];

			switch (wordbites_pieces[i].orientation)
			{
				case WordBitesPieceOrientation_none: buffer[wordbites_pieces[i].position.y + delta.y][wordbites_pieces[i].position.x + delta.x][2] = ']'; break;
				case WordBitesPieceOrientation_hort: buffer[wordbites_pieces[i].position.y + delta.y][wordbites_pieces[i].position.x + delta.x][2] = ')'; break;
				case WordBitesPieceOrientation_vert: buffer[wordbites_pieces[i].position.y + delta.y][wordbites_pieces[i].position.x + delta.x][2] = '/'; break;
			}
		}

		for (u8 x = 0; x < board_dim_slots.x * 3 + 2; x += 1)
		{
			debug_char('.');
		}
		debug_char('\n');
		for (u8 y = 0; y < board_dim_slots.y; y += 1)
		{
			debug_char(':');
			for (u8 x = 0; x < board_dim_slots.x; x += 1)
			{
				debug_chars(&buffer[y][x][0], 3);

				if
				(
					!(
						(board_alphabet_indices[y][x] == ALPHABET_INDEX_VOID && buffer[y][x][1] == '*') ||
						(buffer[y][x][1] == 'A' + board_alphabet_indices[y][x])
					)
				)
				{
					debug_char('\n');
					debug_8H(board_alphabet_indices[y][x]);
					debug_char(' ');
					debug_char(buffer[y][x][1]);
					debug_char('\n');
					debug_8H(board_alphabet_indices[y][x]);
					debug_char('\n');
					error(); // Discrepency!
				}
			}
			debug_cstr(":\n");
		}
		for (u8 x = 0; x < board_dim_slots.x * 3 + 2; x += 1)
		{
			debug_char('.');
		}
		debug_char('\n');
	}
#endif

static_assert(WORDGAME_MAX_DIM_SLOTS_X <= 8);
static_assert(WORDGAME_MAX_DIM_SLOTS_Y <= 15); // Can't be 16, since command of 0xFF is special.
/*
	"command" : 0bS'XXX'YYYY
	"S"       : In Anagrams and WordHunt, this should be set for the last letter of the word in order to submit it; irrelevant for WordBites.
	"X"       : X coordinate of the slot to select.
	"Y"       : Y coordinate of the slot to select.

	If command is NERD_COMMAND_COMPLETE, then this is a signal to the Diplomat that the Nerd is done processing.
	In WordBites, commands should be "paired up", where the first command is where the mouse should pick up the piece,
	and the second command is where the piece should be dropped off.
*/
static void
push_unyielded_command(u8 command)
{
	if ((u8) (unyielded_command_writer + 1) == unyielded_command_reader) // Any open space in command buffer?
	{
		pin_high(PIN_NERD_WAITING);
		usart_rx(); // Wait for the ready signal from the Diplomat.
		pin_low(PIN_NERD_WAITING);
		usart_tx(unyielded_command_buffer[unyielded_command_reader]); // Send out command.
		unyielded_command_reader += 1;                                // A space opened up!
	}

	unyielded_command_buffer[unyielded_command_writer]  = command;
	unyielded_command_writer                           += 1;
}

static void
transpose_wordbites(void)
{
	for (u8 v = 0; v < u8_max(board_dim_slots.x, board_dim_slots.y); v += 1)
	{
		for (u8 u = 0; u < v; u += 1)
		{
			u8 temp = board_alphabet_indices[v][u];
			board_alphabet_indices[v][u] = board_alphabet_indices[u][v];
			board_alphabet_indices[u][v] = temp;
		}
	}

	for (u8 i = 0; i < WORDBITES_PIECES_COUNT; i += 1)
	{
		wordbites_pieces[i].position    = (u8_2) { wordbites_pieces[i].position.y, wordbites_pieces[i].position.x };
		wordbites_pieces[i].orientation =
			wordbites_pieces[i].orientation == WordBitesPieceOrientation_hort ? WordBitesPieceOrientation_vert :
			wordbites_pieces[i].orientation == WordBitesPieceOrientation_vert ? WordBitesPieceOrientation_hort : WordBitesPieceOrientation_none;
	}

	board_dim_slots = (u8_2) { board_dim_slots.y, board_dim_slots.x };
}

static struct WordBitesPiece*
get_wordbites_piece(u8 x, u8 y)
{
	struct WordBitesPiece* result = 0;

	for (struct WordBitesPiece* piece = wordbites_pieces; piece < wordbites_pieces + WORDBITES_PIECES_COUNT; piece += 1)
	{
		u8_2 delta =
			{
				piece->orientation == WordBitesPieceOrientation_hort,
				piece->orientation == WordBitesPieceOrientation_vert,
			};

		if
		(
			(piece->position.x           == x && piece->position.y           == y) ||
			(piece->position.x + delta.x == x && piece->position.y + delta.y == y)
		)
		{
			result = piece;
			break;
		}
	}

	return result;
}

static struct WordBitesPiece*
can_move_wordbites_piece(struct WordBitesPiece* moving_piece, u8 dest_x, u8 dest_y, b8 immediately_move)
{
	struct WordBitesPiece* blocking_piece = 0;

	u8_2 delta =
		{
			moving_piece->orientation == WordBitesPieceOrientation_hort,
			moving_piece->orientation == WordBitesPieceOrientation_vert,
		};

	if // In bounds of the board?
	(
		(u16) dest_x + delta.x < board_dim_slots.x &&
		(u16) dest_y + delta.y < board_dim_slots.y
	)
	{
		// Lift piece we're moving from the board.
		board_alphabet_indices[moving_piece->position.y          ][moving_piece->position.x          ] = ALPHABET_INDEX_VOID;
		board_alphabet_indices[moving_piece->position.y + delta.y][moving_piece->position.x + delta.x] = ALPHABET_INDEX_VOID;

		if (board_alphabet_indices[dest_y][dest_x] != ALPHABET_INDEX_VOID)
		{
			blocking_piece = get_wordbites_piece(dest_x, dest_y);
		}
		else if (board_alphabet_indices[dest_y + delta.y][dest_x + delta.x] != ALPHABET_INDEX_VOID)
		{
			blocking_piece = get_wordbites_piece(dest_x + delta.x, dest_y + delta.y);
		}
		else if (immediately_move)
		{
			moving_piece->position.x = dest_x;
			moving_piece->position.y = dest_y;
		}

		// Place piece back on the board.
		board_alphabet_indices[moving_piece->position.y          ][moving_piece->position.x          ] = moving_piece->alphabet_indices[0];
		board_alphabet_indices[moving_piece->position.y + delta.y][moving_piece->position.x + delta.x] = moving_piece->alphabet_indices[1];
	}
	else
	{
		blocking_piece = moving_piece;
	}

	return blocking_piece;
}

static void
relocate_wordbites_piece
(
	b8                   (*reserved_board_slots)[WORDGAME_MAX_DIM_SLOTS][WORDGAME_MAX_DIM_SLOTS],
	struct WordBitesPiece* piece
)
{
	b8   relocated = false;
	u8_2 delta     =
		{
			piece->orientation == WordBitesPieceOrientation_hort,
			piece->orientation == WordBitesPieceOrientation_vert,
		};

	for
	(
		u8 y = 0;
		y + delta.y < board_dim_slots.y;
		y += 1
	)
	{
		for
		(
			u8 x = 0;
			x + delta.x < board_dim_slots.x;
			x += 1
		)
		{
			if
			(
				!(*reserved_board_slots)[y          ][x          ] &&
				!(*reserved_board_slots)[y + delta.y][x + delta.x] &&
				!can_move_wordbites_piece(piece, x, y, true)
			)
			{
				relocated = true;
				goto RELOCATED;
			}
		}
	}
	RELOCATED:;

	if (!relocated)
	{
		error(); // We couldn't relocate the piece for some reason...
	}
}

int
main(void)
{
	sei();

	#if DEBUG // Configure USART0 to have 250Kbps. See: Source(27) @ Table(22-12) @ Page(226).
		UCSR0A = 1 << U2X0;
		UBRR0  = 7;
		UCSR0B = (1 << TXEN0) | (1 << RXEN0);
		debug_cstr("\n\n--------------------------------\n\n"); // If terminal is opened early, lots of junk could appear due to noise; this helps separate.
	#endif

	pin_output(PIN_NERD_WAITING);

	usart_init();
	spi_init();
	timer_init();
	sd_init();

	//
	// Find sectors of the word stream binary file.
	//

	u32 word_stream_cluster_addresses[32] = {0}; // Zero is never a valid cluster address.
	u8  sectors_per_cluster_exp           = 0;   // Max value is 7.

	{
		//
		// Read master boot record.
		//

		sd_read(0);
		struct MasterBootRecord* mbr = (struct MasterBootRecord*) &sd_sector;
		static_assert(sizeof(*mbr) == sizeof(sd_sector));

		if (mbr->partitions[0].partition_type != MASTER_BOOT_RECORD_PARTITION_TYPE_FAT32_LBA)
		{
			error(); // Unknown partition type..!
		}

		u32 boot_sector_address = mbr->partitions[0].fst_sector_address;

		//
		// Read FAT32 boot sector.
		//

		sd_read(boot_sector_address);
		struct FAT32BootSector* boot_sector = (struct FAT32BootSector*) &sd_sector;
		static_assert(sizeof(*boot_sector) == sizeof(sd_sector));

		if
		(
			!(
				boot_sector->BPB_BytsPerSec == FAT32_SECTOR_SIZE
				&& (boot_sector->BPB_SecPerClus & (boot_sector->BPB_SecPerClus - 1)) == 0
				&& boot_sector->BPB_RootEntCnt == 0
				&& boot_sector->BPB_TotSec16 == 0
				&& boot_sector->BPB_FATSz16 == 0
				&& boot_sector->BPB_FSVer == 0
				&& boot_sector->BS_Reserved == 0
				&& boot_sector->BS_BootSig == 0x29
				&& memeq("FAT32   ", boot_sector->BS_FilSysType, sizeof(boot_sector->BS_FilSysType))
				&& boot_sector->BS_BootSign == 0xAA55
			)
		)
		{
			error(); // Not the boot sector we're expecting...
		}

		for (u8 i = 0; i < 8; i += 1) // Get exponent of sectors per cluster.
		{
			if (boot_sector->BPB_SecPerClus & (1 << i))
			{
				sectors_per_cluster_exp = i;
				break;
			}
		}

		u32 root_cluster        = boot_sector->BPB_RootClus;
		u32 fat_address         = boot_sector_address + boot_sector->BPB_RsvdSecCnt;
		u32 data_region_address = fat_address + boot_sector->BPB_NumFATs * boot_sector->BPB_FATSz32;

		//
		// Search through root directory for the word stream binary file.
		//

		char word_stream_file_name[FAT32_SHORT_NAME_LENGTH + FAT32_SHORT_EXTENSION_LENGTH] = {0};
		memset(word_stream_file_name, ' ', sizeof(word_stream_file_name));

		static_assert(sizeof(WORD_STREAM_NAME) - 1 <= FAT32_SHORT_NAME_LENGTH);
		for (u8 i = 0; i < sizeof(WORD_STREAM_NAME) - 1; i += 1)
		{
			word_stream_file_name[i] = to_upper(pgm_char(PSTR(WORD_STREAM_NAME)[i]));
		}
		static_assert(sizeof(WORD_STREAM_EXTENSION) - 1 <= FAT32_SHORT_EXTENSION_LENGTH);
		for (u8 i = 0; i < sizeof(WORD_STREAM_EXTENSION) - 1; i += 1)
		{
			word_stream_file_name[FAT32_SHORT_NAME_LENGTH + i] = to_upper(pgm_char(PSTR(WORD_STREAM_EXTENSION)[i]));
		}

		for
		(
			u32 cluster = root_cluster;
			(cluster & 0x0FFF'FFFF) != 0x0FFF'FFFF;
		)
		{
			for (u8 sector_index = 0; sector_index < (1 << sectors_per_cluster_exp); sector_index += 1)
			{
				sd_read(data_region_address + ((cluster - 2) << sectors_per_cluster_exp) + sector_index);

				for (u8 entry_index = 0; entry_index < sizeof(sd_sector) / sizeof(union FAT32DirEntry); entry_index += 1)
				{
					// Short entries are only considered; long entries can be done, but that's a lot of complexity for not much.
					struct FAT32DirEntryShort* entry = &((union FAT32DirEntry*) &sd_sector)[entry_index].short_entry;
					static_assert(countof(word_stream_file_name) == countof(entry->DIR_Name));

					if (!entry->DIR_Name[0]) // Current and future entries are unallocated.
					{
						goto STOP_SEARCHING_ROOT_DIRECTORY;
					}
					else if
					(
						entry->DIR_Name[0] != 0xE5                                                                 // Entry is allocated.
						&& !(entry->DIR_Attr & ~(FAT32DirEntryAttrFlag_archive | FAT32DirEntryAttrFlag_read_only)) // Attributes indicate short entry of a file.
						&& memeq(word_stream_file_name, entry->DIR_Name, countof(entry->DIR_Name))                 // File name matches?
					)
					{
						u8                                     last_language_max_word_length = pgm_u8(WORDS_TABLE_OF_CONTENTS[Language_COUNT - 1].max_word_length);
						u8                                     last_language_alphabet_length = pgm_u8(LANGUAGE_INFO[Language_COUNT - 1].alphabet_length);
						const struct WordsTableOfContentEntry* last_entry                    =
							pgm_ptr(struct WordsTableOfContentEntry, WORDS_TABLE_OF_CONTENTS[Language_COUNT - 1].entries)
								+ (last_language_max_word_length - MIN_WORD_LENGTH + 1) * last_language_alphabet_length
								- 1;
						if
						(
							entry->DIR_FileSize !=
								((u32) pgm_u16(last_entry->sector_index)) * FAT32_SECTOR_SIZE
									+ pgm_u16(last_entry->count) * PACKED_WORD_SIZE(MIN_WORD_LENGTH)
						)
						{
							error(); // Binary file mismatching with our table of contents on flash...
						}

						// We'll later convert it to sector address.
						word_stream_cluster_addresses[0] = (((u32) entry->DIR_FstClusHI) << 16) | entry->DIR_FstClusLO;

						goto STOP_SEARCHING_ROOT_DIRECTORY;
					}
				}
			}

			sd_read(fat_address + cluster / FAT32_CLUSTER_ENTRIES_PER_TABLE_SECTOR);
			cluster = ((u32*) sd_sector)[cluster % FAT32_CLUSTER_ENTRIES_PER_TABLE_SECTOR];
		}
		STOP_SEARCHING_ROOT_DIRECTORY:;

		if (!word_stream_cluster_addresses[0])
		{
			error(); // We couldn't find the word stream binary file!
		}

		//
		// Get all clusters' sector addresses of the file.
		//

		for
		(
			u8 cluster_index = 0;
			;
			cluster_index += 1
		)
		{
			// Get sector of FAT corresponding to the current cluster to get the following cluster.
			sd_read(fat_address + word_stream_cluster_addresses[cluster_index] / FAT32_CLUSTER_ENTRIES_PER_TABLE_SECTOR);
			u32 next_cluster = ((u32*) sd_sector)[word_stream_cluster_addresses[cluster_index] % FAT32_CLUSTER_ENTRIES_PER_TABLE_SECTOR];

			// Convert cluster into sector address.
			word_stream_cluster_addresses[cluster_index] = data_region_address + ((word_stream_cluster_addresses[cluster_index] - 2) << sectors_per_cluster_exp);

			if (next_cluster == 0x0FFF'FFFF)
			{
				break; // End of cluster chain.
			}
			else if (cluster_index + 1 < (u8) countof(word_stream_cluster_addresses))
			{
				word_stream_cluster_addresses[cluster_index + 1] = next_cluster; // Will be converted to sector address on next iteration.
			}
			else
			{
				error(); // Too many clusters and not enough space!
			}
		}
	}

	//
	// Wait for packet from Diplomat.
	//

	usart_rx();                         // Dummy byte sent by Diplomat indicating that the game has begun.
	u32 timesup_timestamp = timer_ms(); // Later added with duration of wordgame.

	pin_high(PIN_NERD_WAITING);
	struct DiplomatPacket diplomat_packet = {0};
	for (u8 i = 0; i < sizeof(diplomat_packet); i += 1)
	{
		((u8*) &diplomat_packet)[i] = usart_rx();
	}
	pin_low(PIN_NERD_WAITING);

	//
	// Parse packet.
	//

	enum Language language                           = pgm_u8(WORDGAME_INFO[diplomat_packet.wordgame].language);
	u8            max_word_length                    = pgm_u8(WORDGAME_INFO[diplomat_packet.wordgame].max_word_length);
	b8            alphabet_used[MAX_ALPHABET_LENGTH] = {0};

	board_dim_slots =
		(u8_2)
		{
			pgm_u8(WORDGAME_INFO[diplomat_packet.wordgame].dim_slots.x),
			pgm_u8(WORDGAME_INFO[diplomat_packet.wordgame].dim_slots.y),
		};

	for (u8 y = 0; y < board_dim_slots.y; y += 1)
	{
		for (u8 x = 0; x < board_dim_slots.x; x += 1)
		{
			if (diplomat_packet.board[y][x])
			{
				b8 found = false;
				for (u8 alphabet_index = 0; alphabet_index < pgm_u8(LANGUAGE_INFO[language].alphabet_length); alphabet_index += 1)
				{
					if (pgm_u8(LANGUAGE_INFO[language].alphabet[alphabet_index]) == diplomat_packet.board[y][x])
					{
						found                         = true;
						alphabet_used[alphabet_index] = true;
						board_alphabet_indices[y][x]  = alphabet_index;
						break;
					}
				}
				if (!found)
				{
					error(); // OCR identified a letter that's not in the language's alphabet...
				}
			}
			else
			{
				board_alphabet_indices[y][x] = ALPHABET_INDEX_VOID; // Make slot unusable.
			}
		}
	}

	switch (diplomat_packet.wordgame)
	{
		case WordGame_anagrams_english_6 :
		case WordGame_anagrams_english_7 :
		case WordGame_anagrams_russian   :
		case WordGame_anagrams_french    :
		case WordGame_anagrams_german    :
		case WordGame_anagrams_spanish   :
		case WordGame_anagrams_italian   : timesup_timestamp += 60'000; break;
		case WordGame_wordhunt_4x4       :
		case WordGame_wordhunt_o         :
		case WordGame_wordhunt_x         :
		case WordGame_wordhunt_5x5       :
		case WordGame_wordbites          : timesup_timestamp += 80'000; break;
		case WordGame_COUNT              : error(); // Impossible.
	}

	//
	// Find WordBites pieces.
	//

	if (diplomat_packet.wordgame == WordGame_wordbites)
	{
		u8 wordbites_pieces_count = 0;

		for (u8 y = 0; y < board_dim_slots.y; y += 1)
		{
			for (u8 x = 0; x < board_dim_slots.x; x += 1)
			{
				if
				(
					board_alphabet_indices[y][x] != ALPHABET_INDEX_VOID                     && // There's a letter on this slot!
					implies(x, board_alphabet_indices[y    ][x - 1] == ALPHABET_INDEX_VOID) && // Must be beginning of horizontal piece.
					implies(y, board_alphabet_indices[y - 1][x    ] == ALPHABET_INDEX_VOID)    // Must be beginning of vertical piece.
				)
				{
					if (wordbites_pieces_count == WORDBITES_PIECES_COUNT)
					{
						error(); // More pieces than expected...
					}

					wordbites_pieces[wordbites_pieces_count] =
						(struct WordBitesPiece)
						{
							.position.x          = x,
							.position.y          = y,
							.alphabet_indices[0] = board_alphabet_indices[y][x],
						};

					if (x + 1 < board_dim_slots.x && board_alphabet_indices[y][x + 1] != ALPHABET_INDEX_VOID)
					{
						wordbites_pieces[wordbites_pieces_count].orientation         = WordBitesPieceOrientation_hort;
						wordbites_pieces[wordbites_pieces_count].alphabet_indices[1] = board_alphabet_indices[y][x + 1];
					}
					else if (y + 1 < board_dim_slots.y && board_alphabet_indices[y + 1][x] != ALPHABET_INDEX_VOID)
					{
						wordbites_pieces[wordbites_pieces_count].orientation         = WordBitesPieceOrientation_vert;
						wordbites_pieces[wordbites_pieces_count].alphabet_indices[1] = board_alphabet_indices[y + 1][x];
					}
					else
					{
						wordbites_pieces[wordbites_pieces_count].orientation         = WordBitesPieceOrientation_none;
						wordbites_pieces[wordbites_pieces_count].alphabet_indices[1] = board_alphabet_indices[y][x];
					}

					wordbites_pieces_count += 1;
				}
			}
		}

		if (wordbites_pieces_count != WORDBITES_PIECES_COUNT)
		{
			error(); // Less pieces than expected...
		}

		debug_wordbites_board();
		for (u8 i = 0; i < WORDBITES_PIECES_COUNT; i += 1)
		{
			debug_wordbites_piece(wordbites_pieces[i]);
		}
	}

	//
	// Process for words.
	//

	const struct WordsTableOfContentEntry* curr_table_entry = pgm_read_ptr(&WORDS_TABLE_OF_CONTENTS[language].entries);
	for
	(
		u8 entry_word_length = pgm_u8(WORDS_TABLE_OF_CONTENTS[language].max_word_length);
		entry_word_length >= MIN_WORD_LENGTH;
		entry_word_length -= 1
	)
	{
		for
		(
			u8 initial_alphabet_index = 0;
			initial_alphabet_index < pgm_u8(LANGUAGE_INFO[language].alphabet_length);
			initial_alphabet_index += 1,
			curr_table_entry += 1
		)
		{
			if (alphabet_used[initial_alphabet_index])
			{
				u16 curr_cluster_index        = pgm_u16(curr_table_entry->sector_index) >> sectors_per_cluster_exp;
				u8  curr_cluster_sector_index = pgm_u16(curr_table_entry->sector_index) & ((1 << sectors_per_cluster_exp) - 1);
				u16 entries_remaining         = pgm_u16(curr_table_entry->count);
				while (entries_remaining)
				{
					sd_read(word_stream_cluster_addresses[curr_cluster_index] + curr_cluster_sector_index);

					for
					(
						u16 sector_byte_index = 0;
						sector_byte_index + PACKED_WORD_SIZE(entry_word_length) <= FAT32_SECTOR_SIZE && entries_remaining;
					)
					{
						//
						// Get subword bitfield.
						//

						u16 subword_bitfield = pgm_u16(pgm_u16_ptr(WORDS_TABLE_OF_CONTENTS[language].subfields)[sd_sector[sector_byte_index]]);
						sector_byte_index += 1;

						//
						// Get alphabet indices.
						//

						// +2 since the unpacking process writes up to three elements at a time.
						u8 word_alphabet_indices[ABSOLUTE_MAX_WORD_LENGTH + 2] = { initial_alphabet_index };

						static_assert(BITS_PER_ALPHABET_INDEX == 5);
						for
						(
							u8 word_alphabet_indices_index = 1;
							word_alphabet_indices_index < entry_word_length;
							word_alphabet_indices_index += 3
						)
						{
							// This is technically invoking UB if we happen to be trying to read a u16 at the last byte of the sector,
							// but this shaves off some instructions, so I think it's worth it. AVR-GCC seems to be kinda dumb, so it's a safe bet for me!
							u16 packed = *(u16*) &sd_sector[sector_byte_index];

							word_alphabet_indices[word_alphabet_indices_index] = packed & 0b0001'1111;

							if (word_alphabet_indices_index + 1 < entry_word_length)
							{
								word_alphabet_indices[word_alphabet_indices_index + 1] = (packed >>  5) & 0b0001'1111;
								word_alphabet_indices[word_alphabet_indices_index + 2] = (packed >> 10) & 0b0001'1111;
								sector_byte_index += 2;
							}
							else
							{
								sector_byte_index += 1;
							}
						}

						//
						// Truncate the word to only contain the provided letters of the bank.
						//

						u8 subword_length = 1;
						while (subword_length < entry_word_length && subword_length < max_word_length && alphabet_used[word_alphabet_indices[subword_length]])
						{
							subword_length += 1;
						}

						//
						// Test for reproducibility of subwords.
						//

						u16 subword_bits = subword_bitfield << (15 - (subword_length - MIN_WORD_LENGTH));
						for
						(
							;
							subword_length >= MIN_WORD_LENGTH && subword_bits;
							subword_length -= 1
						)
						{
							if (subword_bits & (1 << 15))
							{
								//
								// Generate Nerd commands.
								//

								u8 command_buffer[255] = {0};
								u8 command_count       = 0;
								switch (diplomat_packet.wordgame)
								{
									// An optimization can be made where if a subword can be reproduced,
									// then all of the subwords shorter than that can also be reproduced.
									// This optimization can be done, but there's already a huge bottleneck on the Diplomat's end
									// of executing these commands already, so it's not going to buy us much anyways.
									case WordGame_anagrams_english_6:
									case WordGame_anagrams_english_7:
									case WordGame_anagrams_russian:
									case WordGame_anagrams_french:
									case WordGame_anagrams_german:
									case WordGame_anagrams_spanish:
									case WordGame_anagrams_italian:
									{
										static_assert(countof(command_buffer) >= ABSOLUTE_MAX_WORD_LENGTH);
										command_count = subword_length; // This exact amount of commands will be created if reproducible.

										//
										// Find matching slots.
										//

										for (u8 subword_letter_index = 0; subword_letter_index < subword_length; subword_letter_index += 1)
										{
											command_buffer[subword_letter_index] = -1; // Assume no matching slot.

											for (u8 slot_index = 0; slot_index < board_dim_slots.x; slot_index += 1)
											{
												if (board_alphabet_indices[0][slot_index] == word_alphabet_indices[subword_letter_index]) // Matching slot?
												{
													board_alphabet_indices[0][slot_index] |= ALPHABET_INDEX_VOID;
													command_buffer[subword_letter_index]   = slot_index << 4;
													break;
												}
											}

											if (command_buffer[subword_letter_index] == (u8) -1) // Didn't find a matching slot?
											{
												command_count = 0; // Not reproducible!
												break;
											}
										}

										if (command_count)
										{
											command_buffer[command_count - 1] |= NERD_COMMAND_SUBMIT_BIT;
										}

										//
										// Clear the void bits of the board.
										//

										for (u8 slot_index = 0; slot_index < board_dim_slots.x; slot_index += 1)
										{
											board_alphabet_indices[0][slot_index] &= ~ALPHABET_INDEX_VOID;
										}
									} break;

									// Like with Anagrams, an optimization can be done where if subword is reproducible,
									// so are of the subwords shorter than it. This again can be done, but we're already bottlenecked by
									// the Diplomat taking a while to execute the commands already.
									case WordGame_wordhunt_4x4:
									case WordGame_wordhunt_o:
									case WordGame_wordhunt_x:
									case WordGame_wordhunt_5x5:
									{
										static_assert(countof(command_buffer) >= ABSOLUTE_MAX_WORD_LENGTH);

										//
										// Find starting point for the subword.
										//

										for (u8 start_y = 0; start_y < board_dim_slots.y; start_y += 1)
										{
											for (u8 start_x = 0; start_x < board_dim_slots.x; start_x += 1)
											{
												if (board_alphabet_indices[start_y][start_x] == word_alphabet_indices[0])
												{
													board_alphabet_indices[start_y][start_x] |= ALPHABET_INDEX_VOID;
													command_buffer[0] = (start_x << 4) | start_y;

													//
													// Find the steps to go in.
													//

													u8 reproduced_subword_length = 1;
													i8 delta_x                   = -2;
													i8 delta_y                   = -1;
													while (true)
													{
														//
														// Get next step.
														//

														b8 found_next = false;
														u8 next_x     = 0;
														u8 next_y     = 0;
														while (true)
														{
															delta_x += 1;
															if (delta_x == 2)
															{
																delta_x = -1;
																delta_y += 1;
															}

															if (delta_y == 2)
															{
																break; // Exhausted all directions to move in.
															}
															else
															{
																next_x = NERD_COMMAND_X(command_buffer[reproduced_subword_length - 1]) + delta_x;
																next_y = NERD_COMMAND_Y(command_buffer[reproduced_subword_length - 1]) + delta_y;

																if // Within bounds and matches?
																(
																	next_x < board_dim_slots.x &&
																	next_y < board_dim_slots.y &&
																	board_alphabet_indices[next_y][next_x] == word_alphabet_indices[reproduced_subword_length]
																)
																{
																	found_next = true;
																	break;
																}
															}
														}

														//
														// Make move or backtrack.
														//

														if (found_next)
														{
															board_alphabet_indices[next_y][next_x]    |= ALPHABET_INDEX_VOID;
															command_buffer[reproduced_subword_length]  = (next_x << 4) | next_y;
															reproduced_subword_length += 1;
															delta_x                    = -2;
															delta_y                    = -1;

															if (reproduced_subword_length == subword_length) // Reproduced entire subword.
															{
																break;
															}
														}
														else if (reproduced_subword_length == 1)
														{
															break; // Can't backtrack any further.
														}
														else // Backtrack.
														{
															board_alphabet_indices
																[NERD_COMMAND_Y(command_buffer[reproduced_subword_length - 1])]
																[NERD_COMMAND_X(command_buffer[reproduced_subword_length - 1])] &= ~ALPHABET_INDEX_VOID;
															delta_x                    = NERD_COMMAND_X(command_buffer[reproduced_subword_length - 1]);
															delta_x                   -= NERD_COMMAND_X(command_buffer[reproduced_subword_length - 2]);
															delta_y                    = NERD_COMMAND_Y(command_buffer[reproduced_subword_length - 1]);
															delta_y                   -= NERD_COMMAND_Y(command_buffer[reproduced_subword_length - 2]);
															reproduced_subword_length -= 1;
														}
													}

													//
													// Clear void bits.
													//

													if (reproduced_subword_length == subword_length) // We're done!
													{
														command_count = subword_length;
														command_buffer[command_count - 1] |= NERD_COMMAND_SUBMIT_BIT;

														for (u8 i = 0; i < subword_length; i += 1)
														{
															board_alphabet_indices
																[NERD_COMMAND_Y(command_buffer[i])]
																[NERD_COMMAND_X(command_buffer[i])] &= ~ALPHABET_INDEX_VOID;
														}

														goto WORDHUNT_REPRODUCIBLE;
													}
													else // This starting spot didn't work out, let's try the next one.
													{
														board_alphabet_indices[start_y][start_x] &= ~ALPHABET_INDEX_VOID;
													}
												}
											}
										}
										WORDHUNT_REPRODUCIBLE:;
									} break;

									case WordGame_wordbites:
									{
										//
										// Find an optimal sequence of commands.
										//

										u8_2                  best_board_dim_slots = {0};
										u8                    best_board_alphabet_indices[WORDGAME_MAX_DIM_SLOTS][WORDGAME_MAX_DIM_SLOTS] = {0};
										struct WordBitesPiece best_wordbites_pieces[WORDBITES_PIECES_COUNT] = {0};
										u8                    best_command_buffer[255] = {0};
										u8                    best_command_count = 0;

										while (true)
										{
											b8 reproducible = true;

											struct UnresolvedPiece
											{
												u8                      goal_alphabet_index;
												struct WordBitesPiece** playing_piece;
											};

											struct WordBitesPiece* playing_pieces[ABSOLUTE_MAX_WORD_LENGTH]  = {0};
											u8                     playing_pieces_count                      = 0;
											struct UnresolvedPiece unresolved_pieces[WORDBITES_PIECES_COUNT] = {0};
											u8                     unresolved_pieces_count                   = 0;

											if (subword_length <= board_dim_slots.x) // Word can fit on board in this orientation?
											{
												//
												// Find pieces for the letters of the subword.
												//

												for
												(
													u8 subword_letter_index = 0;
													subword_letter_index < subword_length;
												)
												{
													//
													// Find a piece that can match the upcoming letter or letters, prioritizing horizontal pieces.
													//

													for (struct WordBitesPiece* piece = wordbites_pieces; piece < wordbites_pieces + WORDBITES_PIECES_COUNT; piece += 1)
													{
														if // Matching horizontal piece?
														(
															subword_letter_index + 1 < subword_length // Can't match if there's one letter left...
															&& piece->orientation == WordBitesPieceOrientation_hort
															&& piece->alphabet_indices[0] == word_alphabet_indices[subword_letter_index    ]
															&& piece->alphabet_indices[1] == word_alphabet_indices[subword_letter_index + 1]
														)
														{
															playing_pieces[playing_pieces_count] = piece;
															break;
														}
														else if // Matching singleton piece?
														(
															piece->orientation == WordBitesPieceOrientation_none
															&& piece->alphabet_indices[0] == word_alphabet_indices[subword_letter_index]
														)
														{
															playing_pieces[playing_pieces_count] = piece;
														}
													}

													//
													// Determine if the piece is resolved or not.
													//

													if (playing_pieces[playing_pieces_count])
													{
														switch (playing_pieces[playing_pieces_count]->orientation)
														{
															case WordBitesPieceOrientation_none: subword_letter_index += 1; break;
															case WordBitesPieceOrientation_hort: subword_letter_index += 2; break;
															case WordBitesPieceOrientation_vert: error(); break; // Impossible.
														}

														playing_pieces[playing_pieces_count]->alphabet_indices[0] |= ALPHABET_INDEX_VOID; // Mark piece as used!
													}
													else // Mark the playing piece as unresolved.
													{
														if (unresolved_pieces_count >= countof(unresolved_pieces))
														{
															error(); // Shouldn't happen based on max word length.
														}

														unresolved_pieces[unresolved_pieces_count] =
															(struct UnresolvedPiece)
															{
																.goal_alphabet_index = word_alphabet_indices[subword_letter_index],
																.playing_piece       = &playing_pieces[playing_pieces_count],
															};
														unresolved_pieces_count += 1;
														subword_letter_index    += 1;
													}

													playing_pieces_count += 1;
												}

												//
												// Resolve pieces.
												//

												u8                     resolved_count  = 0;
												struct WordBitesPiece* resolving_piece = &wordbites_pieces[0];
												while (true)
												{
													if (resolved_count == unresolved_pieces_count) // We fixed every unresolved piece!
													{
														break;
													}
													else if (resolving_piece == wordbites_pieces + WORDBITES_PIECES_COUNT)
													{
														if (resolved_count) // Backtrack.
														{
															resolved_count                                                          -= 1;
															resolving_piece                                                          = *unresolved_pieces[resolved_count].playing_piece + 1;
															(*unresolved_pieces[resolved_count].playing_piece)->alphabet_indices[0] &= ~ALPHABET_INDEX_VOID;
															(*unresolved_pieces[resolved_count].playing_piece)                       = 0;
														}
														else // Exhausted all combinations.
														{
															reproducible = false;
															break;
														}
													}
													else if // Matching vertical piece that can be used to resolve?
													(
														!(resolving_piece->alphabet_indices[0] & ALPHABET_INDEX_VOID) &&
														resolving_piece->orientation == WordBitesPieceOrientation_vert &&
														(
															resolving_piece->alphabet_indices[0] == unresolved_pieces[resolved_count].goal_alphabet_index ||
															resolving_piece->alphabet_indices[1] == unresolved_pieces[resolved_count].goal_alphabet_index
														)
													)
													{
														resolving_piece->alphabet_indices[0]              |= ALPHABET_INDEX_VOID; // Mark piece as used!
														*unresolved_pieces[resolved_count].playing_piece   = resolving_piece;
														resolved_count                                    += 1;
														resolving_piece                                    = &wordbites_pieces[0];
													}
													else // Try matching next one.
													{
														resolving_piece += 1;
													}
												}

												//
												// Remove void bit of the playing pieces.
												//

												for (u8 playing_piece_index = 0; playing_piece_index < playing_pieces_count; playing_piece_index += 1)
												{
													if (playing_pieces[playing_piece_index])
													{
														playing_pieces[playing_piece_index]->alphabet_indices[0] &= ~ALPHABET_INDEX_VOID;
													}
												}
											}
											else // Word can't even fit on the board!
											{
												reproducible = false;
											}

											//
											// Generate moves for word.
											//

											if (reproducible)
											{
												for (u8 beginning_position_y = 0; beginning_position_y < board_dim_slots.y; beginning_position_y += 1)
												{
													for (u8 beginning_position_x = 0; beginning_position_x < board_dim_slots.x; beginning_position_x += 1)
													{
														u8                    old_board_alphabet_indices[WORDGAME_MAX_DIM_SLOTS][WORDGAME_MAX_DIM_SLOTS] = {0};
														struct WordBitesPiece old_wordbites_pieces      [WORDBITES_PIECES_COUNT]                         = {0};
														memcpy(old_board_alphabet_indices, board_alphabet_indices, sizeof(board_alphabet_indices));
														memcpy(old_wordbites_pieces      , wordbites_pieces      , sizeof(wordbites_pieces));

														//
														// Determine the reserved area.
														//

														b8 reserved_board_slots[WORDGAME_MAX_DIM_SLOTS][WORDGAME_MAX_DIM_SLOTS] = {0};
														u8 letter_index = 0;
														for (u8 playing_piece_index = 0; playing_piece_index < playing_pieces_count; playing_piece_index += 1)
														{
															i8_2 delta = {0};

															switch (playing_pieces[playing_piece_index]->orientation)
															{
																case WordBitesPieceOrientation_none: delta = (i8_2) { 0, 0 }; break;
																case WordBitesPieceOrientation_hort: delta = (i8_2) { 1, 0 }; break;
																case WordBitesPieceOrientation_vert:
																{
																	if (playing_pieces[playing_piece_index]->alphabet_indices[0] == word_alphabet_indices[letter_index])
																	{
																		delta = (i8_2) { 0, 1 }; // Unused letter is below the word.
																	}
																	else
																	{
																		delta = (i8_2) { 0, -1 }; // Unused letter is above the word.
																	}
																} break;
															}

															if // In bounds?
															(
																0 <= beginning_position_x + letter_index + delta.x && beginning_position_x + letter_index + delta.x < board_dim_slots.x &&
																0 <= beginning_position_y                + delta.y && beginning_position_y                + delta.y < board_dim_slots.y
															)
															{
																reserved_board_slots[beginning_position_y          ][beginning_position_x + letter_index          ] = true;
																reserved_board_slots[beginning_position_y + delta.y][beginning_position_x + letter_index + delta.x] = true;
																letter_index += 1 + delta.x;
															}
															else // Can't make the word at this spot!
															{
																break;
															}
														}

														if (letter_index == subword_length) // Can the word even fit on the board at this spot?
														{
															#define PUSH_COMMAND(X, Y) \
																do \
																{ \
																	if (command_count < countof(command_buffer)) \
																	{ \
																		command_buffer[command_count] = ((X) << 4) | (Y); \
																		command_count += 1; \
																	} \
																	else \
																	{ \
																		error(); /* Ran of space! */ \
																	} \
																} \
																while (false)

															//
															// Reserve the space before and after the word.
															//

															if (beginning_position_x) // Put a space before the word.
															{
																reserved_board_slots[beginning_position_y][beginning_position_x - 1] = true;
															}

															if (beginning_position_x + subword_length < board_dim_slots.x) // Put a space after the word.
															{
																reserved_board_slots[beginning_position_y][beginning_position_x + subword_length] = true;
															}

															//
															// Find non-playing pieces that are on the reserved slots and relocate them.
															// Necessary to ensure there's space before and after the word.
															//

															for (struct WordBitesPiece* piece = wordbites_pieces; piece < wordbites_pieces + WORDBITES_PIECES_COUNT; piece += 1)
															{
																b8 is_playing_piece = false;
																for (u8 i = 0; i < playing_pieces_count; i += 1)
																{
																	if (playing_pieces[i] == piece)
																	{
																		is_playing_piece = true;
																		break;
																	}
																}

																if (!is_playing_piece)
																{
																	u8_2 delta =
																		{
																			piece->orientation == WordBitesPieceOrientation_hort,
																			piece->orientation == WordBitesPieceOrientation_vert,
																		};

																	if
																	(
																		reserved_board_slots[piece->position.y          ][piece->position.x          ] ||
																		reserved_board_slots[piece->position.y + delta.y][piece->position.x + delta.x]
																	)
																	{
																		PUSH_COMMAND(piece->position.x, piece->position.y); // Pick up the piece here.
																		relocate_wordbites_piece(&reserved_board_slots, piece);
																		PUSH_COMMAND(piece->position.x, piece->position.y); // Pick up the piece here.

																	}
																}
															}

															//
															// Move the playing pieces to make the word.
															//

															letter_index = 0;
															for (u8 playing_piece_index = 0; playing_piece_index < playing_pieces_count; playing_piece_index += 1)
															{
																u8_2 old_position = playing_pieces[playing_piece_index]->position;
																u8_2 new_position =
																	{
																		beginning_position_x + letter_index,
																		beginning_position_y +
																			(
																				playing_pieces[playing_piece_index]->orientation == WordBitesPieceOrientation_vert &&
																				playing_pieces[playing_piece_index]->alphabet_indices[1] == word_alphabet_indices[letter_index]
																					? -1
																					: 0
																			)
																	};

																if // Only matters if the moving piece actually needs to move.
																(
																	old_position.x != new_position.x ||
																	old_position.y != new_position.y
																)
																{
																	while (true)
																	{
																		struct WordBitesPiece* colliding_piece =
																			can_move_wordbites_piece
																			(
																				playing_pieces[playing_piece_index],
																				new_position.x,
																				new_position.y,
																				true
																			);
																		if (colliding_piece)
																		{
																			PUSH_COMMAND(colliding_piece->position.x, colliding_piece->position.y);
																			relocate_wordbites_piece(&reserved_board_slots, colliding_piece);
																			PUSH_COMMAND(colliding_piece->position.x, colliding_piece->position.y);
																		}
																		else
																		{
																			PUSH_COMMAND(old_position.x, old_position.y);
																			PUSH_COMMAND(new_position.x, new_position.y);
																			break;
																		}
																	}
																}

																letter_index += 1 + (playing_pieces[playing_piece_index]->orientation == WordBitesPieceOrientation_hort);
															}

															//
															// See if the sequence of commands is better than the current best.
															//

															if (!best_command_count || best_command_count > command_count)
															{
																best_board_dim_slots = board_dim_slots;
																best_command_count   = command_count;
																memcpy(best_board_alphabet_indices, board_alphabet_indices, sizeof(board_alphabet_indices));
																memcpy(best_wordbites_pieces      , wordbites_pieces      , sizeof(wordbites_pieces));
																memcpy(best_command_buffer        , command_buffer        , sizeof(command_buffer));
															}

															//
															// Restore state of board before the moves to make the word.
															//

															memcpy(board_alphabet_indices, old_board_alphabet_indices, sizeof(old_board_alphabet_indices));
															memcpy(wordbites_pieces      , old_wordbites_pieces      , sizeof(old_wordbites_pieces));
															command_count = 0;

															break;
															#undef PUSH_COMMAND
														}
													}
												}
											}

											//
											// Try to make word again but in different orientation; perhaps it'll be more optimal!
											//

											transpose_wordbites();
											if (board_dim_slots.x == pgm_u8(WORDGAME_INFO[diplomat_packet.wordgame].dim_slots.x))
											{
												break;
											}
										}

										//
										// Use best command sequence.
										//

										if (best_command_count)
										{
											board_dim_slots = best_board_dim_slots;
											command_count   = best_command_count;
											memcpy(board_alphabet_indices, best_board_alphabet_indices, sizeof(best_board_alphabet_indices));
											memcpy(wordbites_pieces      , best_wordbites_pieces      , sizeof(best_wordbites_pieces));
											memcpy(command_buffer        , best_command_buffer        , sizeof(best_command_buffer));

											// Fix orientation.
											if (board_dim_slots.x == pgm_u8(WORDGAME_INFO[diplomat_packet.wordgame].dim_slots.y))
											{
												transpose_wordbites();

												for (u8 i = 0; i < command_count; i += 1)
												{
													command_buffer[i] = (command_buffer[i] << 4) | (command_buffer[i] >> 4);
												}
											}
										}
									} break;

									case WordGame_COUNT:
									{
										error(); // Impossible.
									} break;
								}

								//
								// Send commands.
								//

								for (u8 i = 0; i < command_count; i += 1)
								{
									push_unyielded_command(command_buffer[i]);
								}

								//
								// Check if we're out of time, but don't do it too frequently or else we slow down too much...
								//

								if (command_count && timer_ms() >= timesup_timestamp)
								{
									goto TIMES_UP;
								}
							}

							subword_bits <<= 1;
						}

						//
						// Yield command.
						//

						if (usart_rx_available() && unyielded_command_reader != unyielded_command_writer)
						{
							usart_rx();
							usart_tx(unyielded_command_buffer[unyielded_command_reader]);
							unyielded_command_reader += 1;
						}

						entries_remaining -= 1;
					}

					curr_cluster_sector_index += 1;
					if (curr_cluster_sector_index == (1 << sectors_per_cluster_exp))
					{
						curr_cluster_index        += 1;
						curr_cluster_sector_index  = 0;
					}
				}
			}
		}
	}
	TIMES_UP:;

	//
	// Send out remaining commands.
	//

	pin_high(PIN_NERD_WAITING);

	b8 times_up = false;
	while (unyielded_command_reader != unyielded_command_writer)
	{
		if (timer_ms() >= timesup_timestamp)
		{
			times_up                 = true;
			unyielded_command_reader = unyielded_command_writer; // Flush buffer, since we're out of time!
		}
		else
		{
			usart_rx();
			usart_tx(unyielded_command_buffer[unyielded_command_reader]);
			unyielded_command_reader += 1;
		}
	}

	usart_rx();
	usart_tx(NERD_COMMAND_COMPLETE);

	pin_low(PIN_NERD_WAITING);

	//
	// Flash to indicate whether or not we ran out of time.
	//

	for (u8 i = 0; i < 8; i += 1)
	{
		if (times_up)
		{
			pin_high(PIN_NERD_WAITING);
			_delay_ms(100.0);
			pin_low(PIN_NERD_WAITING);
			_delay_ms(1000.0);
		}
		else
		{
			pin_high(PIN_NERD_WAITING);
			_delay_ms(1000.0);
			pin_low(PIN_NERD_WAITING);
			_delay_ms(1000.0);
		}
	}

	for(;;);
}
