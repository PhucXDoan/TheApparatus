#define F_CPU                16'000'000
#define PROGRAM_NERD         true
#define BOARD_MEGA_2560_REV3 true
#define PIN_MATRIX_SS        2
#define PIN_SD_SS            3
#define SPI_PRESCALER        SPIPrescaler_2
#define USART_N              3
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <util/crc16.h>
#include <stdint.h>
#include <string.h>
#include "defs.h"
#include "W:/data/words_table_of_contents.h" // Generated by Microservices.c.
#include "pin.c"
#include "misc.c"
#include "usart.c"
#include "spi.c"
#include "sd.c"
#include "timer.c"
#if DEBUG
	#include "matrix.c"
#endif

#if DEBUG
	static void
	debug_chars(char* data, u16 length)
	{
		for (u16 i = 0; i < length; i += 1)
		{
			while (!(UCSR0A & (1 << UDRE0))); // Wait for USART transmission buffer to free up.
			UDR0 = data[i];
		}
	}

	static void
	debug_dump(char* file_path, u16 line_number)
	{
		u64 bits            = ((u64) line_number) << 48;
		u8  file_name_index = 0;
		for (u8 i = 0; file_path[i]; i += 1)
		{
			if (file_path[i] == '/' || file_path[i] == '\\')
			{
				file_name_index = i + 1;
			}
		}
		for
		(
			u8 i = 0;
			i < 6 && file_path[file_name_index + i];
			i += 1
		)
		{
			bits |= ((u64) file_path[file_name_index + i]) << (i * 8);
		}
		matrix_init(); // Reinitialize matrix in case the dump occurred mid communication or we haven't had it initialized yet.
		matrix_set(bits);
		debug_cstr("\nDUMPED @ File(");
		debug_cstr(file_path);
		debug_cstr(") @ Line(");
		debug_u64(line_number);
		debug_cstr(").\n");
	}
#endif

int
main(void)
{
	sei();

	#if DEBUG // Configure USART0 to have 250Kbps. See: Source(27) @ Table(22-12) @ Page(226).
		UCSR0A = 1 << U2X0;
		UBRR0  = 7;
		UCSR0B = 1 << TXEN0;
		debug_cstr("\n\n--------------------------------\n\n"); // If terminal is opened early, lots of junk could appear due to noise; this helps separate.
	#endif

	usart_init();
	spi_init();
	timer_init();

	#if DEBUG // 8x8 LED dot matrix to have visual debug info.
		matrix_init();
	#endif

	sd_init();

	enum Language language = Language_english;
	b8 alphabet_count[MAX_ALPHABET_LENGTH] = {0};
	alphabet_count[Letter_d - Letter_a] = true;
	alphabet_count[Letter_u - Letter_a] = true;
	alphabet_count[Letter_m - Letter_a] = true;
	alphabet_count[Letter_p - Letter_a] = true;
	alphabet_count[Letter_t - Letter_a] = true;
	alphabet_count[Letter_r - Letter_a] = true;
	alphabet_count[Letter_u - Letter_a] = true;
	alphabet_count[Letter_c - Letter_a] = true;
	alphabet_count[Letter_k - Letter_a] = true;


	//
	// Find sectors of the word stream binary file.
	//

	#if DEBUG
		matrix_set
		(
			(((u64) 0b00000000) << (8 * 0)) |
			(((u64) 0b00000000) << (8 * 1)) |
			(((u64) 0b01000010) << (8 * 2)) |
			(((u64) 0b01111110) << (8 * 3)) |
			(((u64) 0b01000010) << (8 * 4)) |
			(((u64) 0b00000000) << (8 * 5)) |
			(((u64) 0b00000000) << (8 * 6)) |
			(((u64) 0b00000000) << (8 * 7))
		);
	#endif

	u32 word_stream_cluster_addresses[32] = {0}; // Zero is never a valid cluster address.
	u8  sectors_per_cluster_exp           = 0;   // Max value is 7.

	{
		//
		// Read master boot record.
		//

		sd_read(0);
		struct MasterBootRecord* mbr = (struct MasterBootRecord*) &sd_sector;
		static_assert(sizeof(*mbr) == sizeof(sd_sector));

		if (mbr->partitions[0].partition_type != MASTER_BOOT_RECORD_PARTITION_TYPE_FAT32_LBA)
		{
			error(); // Unknown partition type..!
		}

		u32 boot_sector_address = mbr->partitions[0].fst_sector_address;

		//
		// Read FAT32 boot sector.
		//

		sd_read(boot_sector_address);
		struct FAT32BootSector* boot_sector = (struct FAT32BootSector*) &sd_sector;
		static_assert(sizeof(*boot_sector) == sizeof(sd_sector));

		if
		(
			!(
				boot_sector->BPB_BytsPerSec == FAT32_SECTOR_SIZE
				&& (boot_sector->BPB_SecPerClus & (boot_sector->BPB_SecPerClus - 1)) == 0
				&& boot_sector->BPB_RootEntCnt == 0
				&& boot_sector->BPB_TotSec16 == 0
				&& boot_sector->BPB_FATSz16 == 0
				&& boot_sector->BPB_FSVer == 0
				&& boot_sector->BS_Reserved == 0
				&& boot_sector->BS_BootSig == 0x29
				&& memeq("FAT32   ", boot_sector->BS_FilSysType, sizeof(boot_sector->BS_FilSysType))
				&& boot_sector->BS_BootSign == 0xAA55
			)
		)
		{
			error(); // Not the boot sector we're expecting...
		}

		for (u8 i = 0; i < 8; i += 1) // Get exponent of sectors per cluster.
		{
			if (boot_sector->BPB_SecPerClus & (1 << i))
			{
				sectors_per_cluster_exp = i;
				break;
			}
		}

		u32 root_cluster        = boot_sector->BPB_RootClus;
		u32 fat_address         = boot_sector_address + boot_sector->BPB_RsvdSecCnt;
		u32 data_region_address = fat_address + boot_sector->BPB_NumFATs * boot_sector->BPB_FATSz32;

		//
		// Search through root directory for the word stream binary file.
		//

		char word_stream_file_name[FAT32_SHORT_NAME_LENGTH + FAT32_SHORT_EXTENSION_LENGTH] = {0};
		memset(word_stream_file_name, ' ', sizeof(word_stream_file_name));

		static_assert(sizeof(WORD_STREAM_NAME) - 1 <= FAT32_SHORT_NAME_LENGTH);
		for (u8 i = 0; i < sizeof(WORD_STREAM_NAME) - 1; i += 1)
		{
			word_stream_file_name[i] = to_upper(pgm_char(PSTR(WORD_STREAM_NAME)[i]));
		}
		static_assert(sizeof(WORD_STREAM_EXTENSION) - 1 <= FAT32_SHORT_EXTENSION_LENGTH);
		for (u8 i = 0; i < sizeof(WORD_STREAM_EXTENSION) - 1; i += 1)
		{
			word_stream_file_name[FAT32_SHORT_NAME_LENGTH + i] = to_upper(pgm_char(PSTR(WORD_STREAM_EXTENSION)[i]));
		}

		for
		(
			u32 cluster = root_cluster;
			(cluster & 0x0FFF'FFFF) != 0x0FFF'FFFF;
		)
		{
			for (u8 sector_index = 0; sector_index < (1 << sectors_per_cluster_exp); sector_index += 1)
			{
				sd_read(data_region_address + ((cluster - 2) << sectors_per_cluster_exp) + sector_index);

				for (u8 entry_index = 0; entry_index < sizeof(sd_sector) / sizeof(union FAT32DirEntry); entry_index += 1)
				{
					// Short entries are only considered; long entries can be done, but that's a lot of complexity for not much.
					struct FAT32DirEntryShort* entry = &((union FAT32DirEntry*) &sd_sector)[entry_index].short_entry;
					static_assert(countof(word_stream_file_name) == countof(entry->DIR_Name));

					if (!entry->DIR_Name[0]) // Current and future entries are unallocated.
					{
						goto STOP_SEARCHING_ROOT_DIRECTORY;
					}
					else if
					(
						entry->DIR_Name[0] != 0xE5                                                                 // Entry is allocated.
						&& !(entry->DIR_Attr & ~(FAT32DirEntryAttrFlag_archive | FAT32DirEntryAttrFlag_read_only)) // Attributes indicate short entry of a file.
						&& memeq(word_stream_file_name, entry->DIR_Name, countof(entry->DIR_Name))                 // File name matches?
					)
					{
						u8                                     last_language_max_word_length = pgm_u8(WORDS_TABLE_OF_CONTENTS[Language_COUNT - 1].max_word_length);
						u8                                     last_language_alphabet_length = pgm_u8(LANGUAGE_INFO[Language_COUNT - 1].alphabet_length);
						const struct WordsTableOfContentEntry* last_entry                    =
							pgm_ptr(struct WordsTableOfContentEntry, WORDS_TABLE_OF_CONTENTS[Language_COUNT - 1].entries)
								+ (last_language_max_word_length - MIN_WORD_LENGTH + 1) * last_language_alphabet_length
								- 1;
						if
						(
							entry->DIR_FileSize !=
								((u32) pgm_u16(last_entry->sector_index)) * FAT32_SECTOR_SIZE
									+ pgm_u16(last_entry->count) * PACKED_WORD_SIZE(MIN_WORD_LENGTH)
						)
						{
							error(); // Binary file mismatching with our table of contents on flash...
						}

						// We'll later convert it to sector address.
						word_stream_cluster_addresses[0] = (((u32) entry->DIR_FstClusHI) << 16) | entry->DIR_FstClusLO;

						goto STOP_SEARCHING_ROOT_DIRECTORY;
					}
				}
			}

			sd_read(fat_address + cluster / FAT32_CLUSTER_ENTRIES_PER_TABLE_SECTOR);
			cluster = ((u32*) sd_sector)[cluster % FAT32_CLUSTER_ENTRIES_PER_TABLE_SECTOR];
		}
		STOP_SEARCHING_ROOT_DIRECTORY:;

		if (!word_stream_cluster_addresses[0])
		{
			error(); // We couldn't find the word stream binary file!
		}

		//
		// Get all clusters' sector addresses of the file.
		//

		for
		(
			u8 cluster_index = 0;
			;
			cluster_index += 1
		)
		{
			// Get sector of FAT corresponding to the current cluster to get the following cluster.
			sd_read(fat_address + word_stream_cluster_addresses[cluster_index] / FAT32_CLUSTER_ENTRIES_PER_TABLE_SECTOR);
			u32 next_cluster = ((u32*) sd_sector)[word_stream_cluster_addresses[cluster_index] % FAT32_CLUSTER_ENTRIES_PER_TABLE_SECTOR];

			// Convert cluster into sector address.
			word_stream_cluster_addresses[cluster_index] = data_region_address + ((word_stream_cluster_addresses[cluster_index] - 2) << sectors_per_cluster_exp);

			if (next_cluster == 0x0FFF'FFFF)
			{
				break; // End of cluster chain.
			}
			else if (cluster_index + 1 < (u8) countof(word_stream_cluster_addresses))
			{
				word_stream_cluster_addresses[cluster_index + 1] = next_cluster; // Will be converted to sector address on next iteration.
			}
			else
			{
				error(); // Too many clusters and not enough space!
			}
		}
	}

	//
	// Wait for packet from Diplomat.
	//

	#if DEBUG
		matrix_set
		(
			(((u64) 0b00000000) << (8 * 0)) |
			(((u64) 0b00111110) << (8 * 1)) |
			(((u64) 0b01000000) << (8 * 2)) |
			(((u64) 0b01111100) << (8 * 3)) |
			(((u64) 0b01000000) << (8 * 4)) |
			(((u64) 0b00111110) << (8 * 5)) |
			(((u64) 0b00000000) << (8 * 6)) |
			(((u64) 0b00000000) << (8 * 7))
		);
	#endif

//	struct DiplomatPacket diplomat_packet = {0};
//	for (u8 i = 0; i < sizeof(diplomat_packet); i += 1)
//	{
//		((u8*) &diplomat_packet)[i] = usart_rx();
//	}

	//
	// Process for words.
	//

	#if DEBUG
		matrix_set
		(
			(((u64) 0b00000000) << (8 * 0)) |
			(((u64) 0b00000000) << (8 * 1)) |
			(((u64) 0b01111110) << (8 * 2)) |
			(((u64) 0b00010010) << (8 * 3)) |
			(((u64) 0b00010010) << (8 * 4)) |
			(((u64) 0b00001100) << (8 * 5)) |
			(((u64) 0b00000000) << (8 * 6)) |
			(((u64) 0b00000000) << (8 * 7))
		);
	#endif

	u16 crc         = 0xFF;
	u32 starting_ms = timer_ms();

	const struct WordsTableOfContentEntry* curr_table_entry = pgm_read_ptr(&WORDS_TABLE_OF_CONTENTS[language].entries);
	for
	(
		u8 entry_word_length = pgm_u8(WORDS_TABLE_OF_CONTENTS[language].max_word_length);
		entry_word_length >= MIN_WORD_LENGTH;
		entry_word_length -= 1
	)
	{
		for
		(
			u8 initial_alphabet_index = 0;
			initial_alphabet_index < pgm_u8(LANGUAGE_INFO[language].alphabet_length);
			initial_alphabet_index += 1,
			curr_table_entry += 1
		)
		{
			if (alphabet_count[initial_alphabet_index])
			{
				u16 curr_cluster_index        = pgm_u16(curr_table_entry->sector_index) >> sectors_per_cluster_exp;
				u8  curr_cluster_sector_index = pgm_u16(curr_table_entry->sector_index) & ((1 << sectors_per_cluster_exp) - 1);
				u16 entries_remaining         = pgm_u16(curr_table_entry->count);
				while (entries_remaining)
				{
					sd_read(word_stream_cluster_addresses[curr_cluster_index] + curr_cluster_sector_index);

					for
					(
						u16 sector_byte_index = 0;
						sector_byte_index + PACKED_WORD_SIZE(entry_word_length) <= FAT32_SECTOR_SIZE && entries_remaining;
					)
					{
						//
						// Get subword bitfield.
						//

						u16 subword_bitfield = pgm_u16(pgm_u16_ptr(WORDS_TABLE_OF_CONTENTS[language].subfields)[sd_sector[sector_byte_index]]);
						sector_byte_index += 1;

						//
						// Get alphabet indices.
						//

						// +2 since the unpacking process writes up to three elements at a time.
						u8 word_alphabet_indices[ABSOLUTE_MAX_WORD_LENGTH + 2] = { initial_alphabet_index };

						static_assert(BITS_PER_ALPHABET_INDEX == 5);
						for
						(
							u8 word_alphabet_indices_index = 1;
							word_alphabet_indices_index < entry_word_length;
							word_alphabet_indices_index += 3
						)
						{
							// This is technically invoking UB if we happen to be trying to read a u16 at the last byte of the sector,
							// but this shaves off some instructions, so I think it's worth it. AVR-GCC seems to be kinda dumb, so it's a safe bet for me!
							u16 packed = *(u16*) &sd_sector[sector_byte_index];

							word_alphabet_indices[word_alphabet_indices_index] = packed & 0b0001'1111;

							if (word_alphabet_indices_index + 1 < entry_word_length)
							{
								word_alphabet_indices[word_alphabet_indices_index + 1] = (packed >>  5) & 0b0001'1111;
								word_alphabet_indices[word_alphabet_indices_index + 2] = (packed >> 10) & 0b0001'1111;
								sector_byte_index += 2;
							}
							else
							{
								sector_byte_index += 1;
							}
						}

						//
						// Truncate the word to only contain the provided letters of the bank.
						//

						u8 subword_length = 1;
						while (subword_length < entry_word_length && alphabet_count[word_alphabet_indices[subword_length]])
						{
							subword_length += 1;
						}

						//
						// Test for reproducibility of subwords.
						//

						u16 subword_bits = subword_bitfield << (15 - (subword_length - MIN_WORD_LENGTH));
						for
						(
							;
							subword_length >= MIN_WORD_LENGTH && subword_bits;
							subword_length -= 1
						)
						{
							if (subword_bits & (1 << 15))
							{
								//for (u8 i = 0; i < subword_length; i += 1)
								//{
								//	debug_char('A' + word_alphabet_indices[i]);
								//}
								//debug_char('\n');

								for (u8 i = 0; i < subword_length; i += 1)
								{
									crc = _crc16_update(crc, word_alphabet_indices[i]);
								}
							}

							subword_bits <<= 1;
						}

						entries_remaining -= 1;
					}

					curr_cluster_sector_index += 1;
					if (curr_cluster_sector_index == (1 << sectors_per_cluster_exp))
					{
						curr_cluster_index        += 1;
						curr_cluster_sector_index  = 0;
					}
				}
			}
		}
	}

	u32 elapsed_ms = timer_ms() - starting_ms;

	debug_u64 (crc);
	debug_cstr(" : ");
	debug_u64 (elapsed_ms);
	debug_cstr("ms elapsed.\n");

	//
	// Done!
	//

	matrix_set
	(
		(((u64) 0b00001000) << (8 * 0)) |
		(((u64) 0b00000100) << (8 * 1)) |
		(((u64) 0b00101000) << (8 * 2)) |
		(((u64) 0b01000000) << (8 * 3)) |
		(((u64) 0b01000000) << (8 * 4)) |
		(((u64) 0b00101000) << (8 * 5)) |
		(((u64) 0b00000100) << (8 * 6)) |
		(((u64) 0b00001000) << (8 * 7))
	);

	for(;;);
}
