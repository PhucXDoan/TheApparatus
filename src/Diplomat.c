#define F_CPU 16'000'000
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <avr/wdt.h>
#include <avr/pgmspace.h>
#include <stdint.h>
#include <string.h>
#include "defs.h"
#include "misc.c"
#include "pin.c"
#include "usb.c"
#undef  PIN_HALT_SOURCE
#define PIN_HALT_SOURCE PinHaltSource_usb

static const u16 RNG[] =
	{
		0x295F, 0xFB2B, 0xCEA2, 0x79F4, 0x6370, 0x3FBC, 0x5E9C, 0xB909,
		0xAFE6, 0x1AC2, 0x75C2, 0x3CB9, 0xD595, 0xFBB8, 0x7286, 0xA308,
		0x65A1, 0x2A39, 0x09FF, 0x4F2C, 0x8BBB, 0x5DA3, 0x6888, 0xE8E5,
		0x3461, 0x4CEA, 0x6173, 0xCBE6, 0x798A, 0xD18C, 0x1864, 0xD228,
		0xC1E1, 0x091D, 0x0AA2, 0x22F6, 0x2369, 0x55F5, 0xECE1, 0x60D1,
		0x6D42, 0x34E4, 0x3B95, 0x0DA2, 0xD295, 0x34AC, 0x16DB, 0xC921,
		0x9B83, 0xF2AE, 0x86FB, 0x0846, 0x1AFE, 0x01E3, 0xE6B0, 0xA216,
		0xE7B9, 0x4A5F, 0xD1C7, 0x0EB5, 0x487D, 0xAD6E, 0x69AF, 0xDF74,
		0x5C85, 0x4851, 0xB2F2, 0x7D31, 0x20D8, 0x70E9, 0x1F6A, 0x8AF0,
		0xFA93, 0xB527, 0x8C73, 0xD31E, 0xA6AA, 0x1C81, 0x60CF, 0xC0C5,
		0xED36, 0xBD05, 0x1956, 0xE347, 0x1911, 0x7B73, 0xD78E, 0xCB5D,
		0x05C0, 0x7CC9, 0xC7DB, 0xA908, 0x74D0, 0xA775, 0xF9B5, 0xD63C,
		0x07BC, 0xC630, 0xA0BA, 0x83B0, 0xDB6C, 0x38D7, 0xB22E, 0x7012,
		0xA30E, 0x1439, 0x3D5E, 0x9520, 0x4886, 0xA24D, 0x2234, 0xF940,
		0xA6F4, 0x61A1, 0xE865, 0xD8EA, 0xBDF8, 0x42AC, 0x8F72, 0xE6A5,
		0xCDB6, 0x1275, 0x3020, 0x8886, 0x7B37, 0x41BD, 0x2818, 0xF0F3,
		0xF6E1, 0xFB18, 0x1999, 0x7346, 0x1947, 0x5D9F, 0xB88B, 0xBB7D,
		0xC224, 0xA592, 0xED0B, 0x120F, 0xD2C6, 0x93D6, 0x7B10, 0x1E42,
		0x91F5, 0x3AEE, 0xDFE6, 0xFB86, 0xFBC9, 0xFA1E, 0x74A9, 0x737E,
		0x72F8, 0xA9A0, 0xD872, 0x54A8, 0x30C0, 0xD80B, 0xA0A6, 0xE549,
		0x723E, 0xF075, 0x9494, 0xAED2, 0xEFF5, 0x3A6F, 0x47B8, 0xCEE8,
		0xD0F9, 0x7BF2, 0x07F7, 0xB392, 0x3124, 0xFBD0, 0xA595, 0x8861,
		0x4884, 0x0077, 0xA85B, 0xB552, 0x40DF, 0xDAF0, 0xF0FF, 0xE6E6,
		0x3C51, 0x0D53, 0x85CD, 0x0AD0, 0xF2A1, 0x9115, 0x4144, 0x9C6B,
		0xF3E7, 0x3A39, 0xA361, 0x47AE, 0xCCA6, 0x5F54, 0x971B, 0xA85F,
		0xB63D, 0x7BAF, 0xAB57, 0xEC13, 0xC9F9, 0xFB49, 0x2488, 0xCF80,
		0x852C, 0x0548, 0xC0E3, 0xB471, 0x4854, 0xB058, 0x347A, 0x3055,
		0xAA15, 0xF936, 0x4CA2, 0x8BB8, 0x980F, 0x442D, 0x1275, 0xC51E,
		0xF2EB, 0x1B95, 0xEF37, 0xF99D, 0xEC24, 0x2D49, 0xE26B, 0x4EF1,
		0x9E98, 0x1D19, 0x1CC2, 0x248F, 0x5E24, 0x6DA0, 0x0D01, 0xD05F,
		0x0CE3, 0x9735, 0x5BCD, 0x9BE7, 0x42EA, 0xD893, 0xD2E2, 0x4BFC,
		0xF764, 0xFFD7, 0xEADE, 0x609B, 0x3586, 0xC91D, 0x2FA0, 0x0775
	};

int
main(void)
{
	if (USBCON != 0b0010'0000) // [Bootloader-Tampered State].
	{
		wdt_enable(WDTO_15MS);
		for(;;);
	}

	sei();

	usb_init();

	for(;;)
	{
	#if 1
		char c;
		if (debug_rx(&c, 1))
		{
			debug_tx_chars(&c, 1);
		}
	#elif 0
		usb_mouse_command(false, 127, 0);
		_delay_ms(1000.0);

		usb_mouse_command(false, 0, 255);
		_delay_ms(1000.0);

		usb_mouse_command(false, 0, 0);
		_delay_ms(1000.0);
	#elif 0
		usb_mouse_command(false, 0, 0);
		_delay_ms(2000.0);
		usb_mouse_command(false, 127, 255);
		_delay_ms(2000.0);
		usb_mouse_command(false, 0, 0);
		usb_mouse_command(false, 127, 255);
		_delay_ms(2000.0);
	#else
		if (!debug_pin_read(5))
		{
			//usb_mouse_command(false, 0, 0);
			//_delay_ms(1000.0);
			usb_mouse_command(false, 10, 24);
			_delay_ms(1000.0);

			for (u16 i = 0; i + 3 < countof(RNG); i += 3)
			{
				usb_mouse_command(RNG[i] % 2, RNG[i + 1] % 128, RNG[i + 2] % 256);
			}

			usb_mouse_command(false, 10, 24);
			_delay_ms(5'000.0);
		}
	#endif
	}
}

//
// Documentation.
//

/* [Bootloader-Tampered State].
	For the ATmega32U4 that I have, the bootloader is executed whenever the MCU reinitializes from
	an external reset (RST was pulled low); other sources of resets do not. When the bootloader
	hands execution to the main program, it seems to leaves the USB-related registers (e.g. USBCON)
	not with their default values. This is pretty obviously inconvenient for us to set up USB
	correctly, and who knows what other registers are also tampered with by the bootloader!

	To resolve this, we just simply enable the watchdog timer and wait for it to trigger. This
	induces a hardware reset that won't have the MCU start with the bootloader messing around with
	our registers. AVR-GCC pretty much handles all for us, so don't have to worry about the minute
	details like the timed-writing sequences.

	See: "Watchdog Reset" @ Source(1) @ Section(8.6) @ Page(53-54).
	See: "Watchdog Timer" @ Source(1) @ Section(8.9) @ Page(55-56).
*/
